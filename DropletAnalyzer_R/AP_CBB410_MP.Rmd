---
title: "AP_CBB410_MTP"
author: "Arjun S. Pamidi"
date: "`r Sys.Date()`"
output: pdf_document
---

# Introduction (Short Version)
1.) Source of data: Microfluidic droplet generator in the lab I'm rotating in (Diercks Lab). I made an OpenCV program to analyze images of the droplets made by the machine for size and gray value. The entire code base including this R notebook is found at my GitHub for this project: https://github.com/apamidiSCR/DropletAnalyzer. The GitHub page also has the .csv file outputted by my OpenCV program (the input to this R script!). This dataset has ~30,000 observations.
2.) In the Diercks lab, we have a project where we need to precisely inject microfluidic droplets (~15 um starding radius) with reagents. This must be done at high efficiency and low injection volumes or our project won't work optimally. However, it's not intuitive how to accomplish this with the equipment, so we varied a bunch of parameters (described in long version) to see which parameters result in small injection volumes at high efficiency by tracking injections on dark droplets with a light fluid. 
3.) Definition of 5 variables. This is an experiment; there are 3 independent variables (f_emulsion, f_inject, and voltage) representing how fast droplets are flown into the injection junction, how fast the injection solution is injected into the junction, and what voltage is used to promote coalescence of the injection solution with the incoming droplets (called electrocoalescence voltage). The two dependent variables are size and lightness (gray value) of the droplets, but I additionally create variables such as number of successful injections defined by a lightness threshold. I am working under an experimental constraint; for example, you can measure many qualities of a penguin, but you can only really measure two qualities of these droplets. Thus, I hope it's okay that some of my variables are independent variables (conditions that led to the formation of a droplet).

# Introduction (Long Version) Ignore if no time to read this.

This R Notebook analyzes data generated by me and my lab buddy, Meng-han Pan, in the Diercks Lab here at Scripps. Specifically, we've recently been trying to accomplish controlled picoinjection of reagents into
microfluidic droplets. The problem is that these injections are too fast to see and measure by eye -- injections occur between 60 - 200 times per second. While the instrument that does the injections
offers image-based analysis of droplets within a specified area of the microscope, and can export a size distribution of the captured droplets, there are two issues. 1.) We do not know which droplet
a size measurement came from; the data is lost. Thus, we don't know if the instrument calculated the size correctly for a given droplet (it uses neural-network based recognition, which sometimes gets
it wrong.) 2.) The instrument does not measure the darkness of the droplet. This information is important because it can tell us whether or not we actually injected the droplet (if the droplet starts off
dark, and we inject water, the droplet gets lighter). Uninjected droplets remain dark and small, spontaneously injections are small and clear, and succesfully injected droplets are larger and of medium darkness.

Fortunately, the instrument saves a 'collage' of droplet images, each of which ideally contains one droplet as an image. To analyze the droplets with high accuracy, I wrote a c++ program using OpenCV with help from LLM's (my favorite
LLM-enabled IDE is Cursor; this usually outperforms an LLM by itself as Cursor automatically optimizes how the LLM is prompted, what information the LLM has access to, etc.). This program took significant development time (~12-16 hours)
but it was worth it because it's necessary for my main project in lab.

Essentially, you point the program towards a folder on your computer which contains sub-folders, each of which contains a collage for one experiment. We have 3 independent variables: The emulsion flowrate (f_emulsion), the injectant flowrate (f_inject),
and the electrocoalescence voltage (Voltage), and two dependent variables (droplet diamter and droplet grayval (the lightness)), making 5 variables in total. 

For each image within the folder, the OpenCV program blurs the image, upscales it, enhances the contrast, and applies a lightness threshold as preprocessing steps. These make
the next step, Hough circle detection, more accurate. After the circle detection step, the program attempts to hone-in on the inner boundary of the droplet by scanning inwards and outwards on a path perpendicular to 8 points
of the droplet's perimeter to find exactly the inner portion of the droplet's boundary by looking at the lightness of each pixel; there is typically a transition from dark to light when you cross the boundary, which is dark.

At that point, the program has honed in on the most accurate circle it could find representing the inner portion of the droplet. It uses that circle to measure the average grayval within that circle and that circle's diameter. It then
captures an image of the original droplet but with the circle it detected overlaid on top, for quality control purposes. It names the image according the droplet's index, radius, and grayval and puts it in an outputs folder within the
folder containing the collage of images for that experiment.

The final (for now :D) program can analyze ~30,000 droplets in 30 minutes assuming parallelization by running the program on multiple cores; my machine has 16 physical cores (Ryzen 9950X3D) so each core can analyze one collage -> 16 collages simultaneously. 

Next, to prepare the data for analysis in R, I wrote a simple python script. (This maybe could have been done in R, but I think it would have been a pain. For this sort of task, I felt python would be way easier to write and debug even
with help from Cursor).

You point the python script at a csv sheet which links the name of each folder to the experimental conditions used to generate those droplets, and a path to the folder
containing the folders with droplet images in them. The python script then outputs the data in as 'tidy' a format I could think of (you'll see below) in the form of a .csv file. Now, the dataset is ready for analysis in R. The .csv is simply kept in working directory of the R Notebook in a folder called 'Data'.

# Part 1: Data import, cleaning, and mutation.

```{r fig.width=16, fig.height=10}

library(tidyverse)
library(ggplot2)
library(dplyr)
library(extrafont)


# Read the CSV data from the data folder in the RMD directory.
droplet_data <- read_csv(
  "Data/PICOINJ_3_Results.csv",
  col_types = cols(),
  na = c("","NA")
)

# Let's display the first 10 rows of the tibble.
head(droplet_data)

# Let's tidy up the column headers and get rid of the '?', '()', and '.' 's.
droplet_data <- droplet_data %>%
  rename(
    code = 'Code',
    measured = 'Measured?',
    index = 'Index',
    valid = 'Valid?',
    radius_um = 'Radius (um)',
    voltage = 'Voltage',
    f_oil = 'Foil',
    f_emulsion = 'Femulsion',
    f_inject = 'Finject',
    grayval = 'GrayVal (A.U.)',
  )
# This should look better.
head(droplet_data)

# Just to make sure all the data managed to get in here, let's count the number of unique values for f_oil, f_emulsion, f_inject, voltage, and valid.
droplet_data %>%
  distinct(f_oil)

droplet_data %>%
  distinct(f_emulsion)
droplet_data %>%
  distinct(f_inject)
droplet_data %>%
  distinct(voltage)

droplet_data %>%
  distinct(valid)

# Yep, looking at the unique values for each variable shows me that indeed all of the experiments made it into the final csv.
# Here is a quick summary of the data:

droplet_data %>%
  summarise(
    total_experiments = n_distinct(code),
    total_droplets = n(),
    valid_droplets = sum(valid == "VALID", na.rm = TRUE),
    n_f_oil = n_distinct(f_oil),
    n_f_emulsion = n_distinct(f_emulsion),
    n_f_inject = n_distinct(f_inject),
    n_voltage = n_distinct(voltage)
  )

# A goal of this experiment was to find out what the injection volume is. Before we can figure that out, we need to know the droplet volumes.
# Thus, I'll mutate droplet_data to add a column with the droplet volume in picoliters.

droplet_data <- droplet_data %>%
  mutate(
    volume_pL = (4/3) * pi * radius_um^3 * (1e-3)
  )

# Now let's see if that worked.
droplet_data %>%
  select(radius_um, volume_pL)

head(droplet_data)

# Great, that worked. To start with the exploratory analysis, I want to plot histograms of droplet diameters for each electrocoalescence voltage, and
# color the points by grayval.
```

# -------------------------Histogram stuff start ----------------------------

The histograms should satisfy 3 of **Requirement 2C** 's explored variables. # We have one exploratory set for the 250V, 500V, and 750V groups of experiments. All of these require using dplyr's data transformation functions like mutate, filter, cut, etc.

I will use the Freedman-Diaconis rule to determine bin width. This will be most easily implemented with a function. The function accepts one input, x, which is a vector of the observations in the dataset.

```{r fig.width=16, fig.height=10}

fd_binwidth <- function(x) {
  # Use IQR, from stats, to get interquartile range. Remove NA's.
  iqr_val <- IQR(x, na.rm = TRUE)
  # Get size of vector x so we can make sure we have enough observations.
  n <- sum(!is.na(x))
  # Don't want to have invalid bin widths caused by too few droplets.
  if (n < 2 || iqr_val == 0) {
    # If too few droplets, just make the bin width 1/10th the range of the values.
    return(diff(range(x, na.rm = TRUE)) / 10)
  }
  # If the data had enough points, use the FD rule to find it and return it.
  bw <- 2 * iqr_val / (n^(1/3))
  return(bw)
}

# Now that we have this function, let's make a tibble with each experiment code string, the number of valid droplets,
# and the binwidth we should use when plotting the histogram.

# Making the new tibble:
droplet_binwidths <- droplet_data %>%
  # Filter out rows where the droplet was invalid.
  filter(valid == "VALID") %>%
  # Group by unique experiment codes.
  group_by(code) %>%
  # For each group, summarise will count the valid droplets by just counting
  # how many observations the group has (we already filtered out the invalid
  # droplets). When summarise operates on a grouped tibble, functions like
  # fd_binwidth() receive only the values from that specific group.
  # Thus, we can pass the radius_um column into the fd_binwidth function,
  # and it will calculate a binwidth for each group's radius values separately,
  # giving us a new column called binwidth.
  summarise(
    valid_droplets = n(),
    binwidth = fd_binwidth(radius_um)
  )

head(droplet_binwidths)
# Okay, looks like a good tibble. Now, let's prepare a version of droplet_data
# specifically for the histograms (only valid droplets).

valid_droplet_data <- droplet_data %>%
  filter(valid == "VALID")

# Since I want to make one set of histograms per voltage level, we should
# identify each voltage level from the dataset:

voltage_levels <- sort(unique(valid_droplet_data$voltage))

# Display this to check we've got all three:
voltage_levels

# -----------Histograms for 250V Electrocoalescence --------------------------

v1 <- voltage_levels[1]
histogram_data_v1 <- valid_droplet_data %>%
  filter(voltage == v1)

# See if we only have the data from 250V:
table(histogram_data_v1$voltage)

# We have only one value for Voltage in this tibble and it has 8889
# observations associated with it. Let's now join the binwidth onto this tibble.

histogram_data_v1 <- histogram_data_v1 %>%
  left_join(droplet_binwidths, by = 'code')

# And let's see if it makes sense:
histogram_data_v1 %>%
  distinct(code,binwidth)

# Yep, matches the previous binwidth table. It's just that now we only have the
# 250V data. Now it's time to group by binwidths. 

histogram_data_v1 <- histogram_data_v1 %>%
  group_by(f_emulsion, f_inject) %>%
  # Now it's time to use mutate to add a column to the tibble representing
  # which bin the data will go into. This isn't counting how many per bin yet,
  # it's just setting us up for that operation later.
  mutate(
    # Create the new radius_bin column. Cut can divide radius_bin, which is
    # a vector of radii grouped by each unique f_emulsion and f_inject
    # combination, by a width we define.
    radius_bin = cut(
      radius_um,
      # breaks is how we tell cut to...cut.
      breaks = seq(
        # The floor and ceiling operations are to round the bottom of the
        # first bin and the top of the last bin.
        from = floor(min(radius_um, na.rm = TRUE)),
        to = ceiling(max(radius_um, na.rm = TRUE)),
        # Here we use our FD binwidths from before.
        by = binwidth[1]
      ),
      # Include the lowest boundary. The rightmost boundary is already included.
      include.lowest = TRUE
    )
  )
# See if it worked
head(histogram_data_v1)
# Yep, looks like the radii are correctly binned. Now it's time to count how
# many droplets fall into each bin.

histogram_data_v1 <- histogram_data_v1 %>%
  # Group all droplets with same f_emulsion, f_inject, radius bin, and
  # binwidth and code for collapsing
  group_by(f_emulsion, f_inject, code, radius_bin, binwidth) %>%
  summarise(
    # Count
    count = n(),
    # Get the mean grayval (which we can use to color each histogram bar
    # later to give the histograms a bit more depth.
    mean_grayval = mean(grayval, na.rm = TRUE),
    # Now we drop the groups.
    .groups = "drop"
  ) %>%
  # Safety check; get rid of empty bins.
  filter(!is.na(radius_bin)) %>% 
  # Bit of a crazy regex to get the geometric centers of each bin.
  # Thanks Claude.....
    mutate(
    # Extract lower and upper bounds from the bin label
    lower_bound = as.numeric(sub("\\(|\\[", "", sub(",.*", "", radius_bin))),
    upper_bound = as.numeric(sub(".*,", "", sub("\\]|\\)", "", radius_bin))),
    bin_center = (lower_bound + upper_bound) / 2
    )
# Now let's see if this worked properly.
histogram_data_v1 %>%
  select(radius_bin, lower_bound, upper_bound, bin_center) %>%
  head()
# yep, looks good.
# I want to also label each facet by experiment number for ease of interpretation.
facet_labels_v1 <- histogram_data_v1 %>%
  # Each combo is a unique experiment.
  group_by(f_emulsion, f_inject) %>%
  summarise(
    # Claude helped with this regex.
    exp_num = first(as.numeric(str_extract(code, "\\d+$"))),
    .groups = "drop"
  )
# Make a histogram with geom_col:
ggplot(histogram_data_v1, aes(x = bin_center, y = count, fill = mean_grayval)) +
  geom_col(aes(width = binwidth), position = "identity") +
  # Add the labels.
  geom_text(data = facet_labels_v1, 
            aes(x = Inf, y = Inf, label = exp_num),
            hjust = 1.2, vjust = 1.5, 
            inherit.aes = FALSE,
            size = 4, fontface = "bold", color = "black") +
  # Going to facet by the emulsion and injection flowrates.
  # Claude helped me with labeller to get labels with subscripts working.
  facet_grid(f_emulsion ~ f_inject,
           labeller = labeller(
             f_emulsion = as_labeller(
               function(x) paste0("F[emulsion]: ", x, " * mu * L/hr"),
               label_parsed
             ),
             f_inject = as_labeller(
               function(x) paste0("F[inject]: ", x, " * mu * L/hr"),
               label_parsed
             )
           )) +
  # Here we can choose which color scale to use for fills.
  scale_fill_viridis_c(option = "magma", name = "Droplet Lightness") +
  labs(
    title = "Droplet radii at 250V electrocoalescence colored by droplet lightness",
    x = "Droplet Radius (um)",
    y = "Count"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5)
  )
# -----------Histograms for 500V Electrocoalescence --------------------------
# Won't comment this block in as much detail since it's essentially the same
# as the 250V but for the 500V level.
v2 <- voltage_levels[2]
histogram_data_v2 <- valid_droplet_data %>%
  filter(voltage == v2)

histogram_data_v2 <- histogram_data_v2 %>%
  left_join(droplet_binwidths, by = 'code')

histogram_data_v2 <- histogram_data_v2 %>%
  group_by(f_emulsion, f_inject) %>%
  mutate(
    radius_bin = cut(
      radius_um,
      breaks = seq(
        from = floor(min(radius_um, na.rm = TRUE)),
        to = ceiling(max(radius_um, na.rm = TRUE)),
        by = binwidth[1]
      ),
      include.lowest = TRUE
    )
  )

histogram_data_v2 <- histogram_data_v2 %>%
  group_by(f_emulsion, f_inject, code, radius_bin, binwidth) %>%
  summarise(
    count = n(),
    mean_grayval = mean(grayval, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(radius_bin)) %>% 
  mutate(
    lower_bound = as.numeric(sub("\\(|\\[", "", sub(",.*", "", radius_bin))),
    upper_bound = as.numeric(sub(".*,", "", sub("\\]|\\)", "", radius_bin))),
    bin_center = (lower_bound + upper_bound) / 2
  )

facet_labels_v2 <- histogram_data_v2 %>%
  # Each combo is a unique experiment.
  group_by(f_emulsion, f_inject) %>%
  summarise(
    # Claude helped with this regex.
    exp_num = first(as.numeric(str_extract(code, "\\d+$"))),
    .groups = "drop"
  )

ggplot(histogram_data_v2, aes(x = bin_center, y = count, fill = mean_grayval)) +
  geom_col(aes(width = binwidth), position = "identity") +
  geom_text(data = facet_labels_v2, 
            aes(x = Inf, y = Inf, label = exp_num),
            hjust = 1.2, vjust = 1.5, 
            inherit.aes = FALSE,
            size = 4, fontface = "bold", color = "black") +
  facet_grid(f_emulsion ~ f_inject,
           labeller = labeller(
             f_emulsion = as_labeller(
               function(x) paste0("F[emulsion]: ", x, " * mu * L/hr"),
               label_parsed
             ),
             f_inject = as_labeller(
               function(x) paste0("F[inject]: ", x, " * mu * L/hr"),
               label_parsed
             )
           )) +
  scale_fill_viridis_c(option = "magma", name = "Droplet Lightness") +
  labs(
    title = "Droplet radii at 500V electrocoalescence colored by droplet lightness",
    x = "Droplet Radius (um)",
    y = "Count"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5)
  )
# -----------Histograms for 750V Electrocoalescence --------------------------

v3 <- voltage_levels[3]
histogram_data_v3 <- valid_droplet_data %>%
  filter(voltage == v3)

histogram_data_v3 <- histogram_data_v3 %>%
  left_join(droplet_binwidths, by = 'code')

histogram_data_v3 <- histogram_data_v3 %>%
  group_by(f_emulsion, f_inject) %>%
  mutate(
    radius_bin = cut(
      radius_um,
      breaks = seq(
        from = floor(min(radius_um, na.rm = TRUE)),
        to = ceiling(max(radius_um, na.rm = TRUE)),
        by = binwidth[1]
      ),
      include.lowest = TRUE
    )
  )

histogram_data_v3 <- histogram_data_v3 %>%
  group_by(f_emulsion, f_inject, code, radius_bin, binwidth) %>%
  summarise(
    count = n(),
    mean_grayval = mean(grayval, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(radius_bin)) %>% 
  mutate(
    lower_bound = as.numeric(sub("\\(|\\[", "", sub(",.*", "", radius_bin))),
    upper_bound = as.numeric(sub(".*,", "", sub("\\]|\\)", "", radius_bin))),
    bin_center = (lower_bound + upper_bound) / 2
  )

facet_labels_v3 <- histogram_data_v3 %>%
  # Each combo is a unique experiment.
  group_by(f_emulsion, f_inject) %>%
  summarise(
    # Claude helped with this regex.
    exp_num = first(as.numeric(str_extract(code, "\\d+$"))),
    .groups = "drop"
  )

ggplot(histogram_data_v3, aes(x = bin_center, y = count, fill = mean_grayval)) +
  geom_col(aes(width = binwidth), position = "identity") +
  geom_text(data = facet_labels_v3, 
            aes(x = Inf, y = Inf, label = exp_num),
            hjust = 1.2, vjust = 1.5, 
            inherit.aes = FALSE,
            size = 4, fontface = "bold", color = "black") +
  facet_grid(f_emulsion ~ f_inject,
           labeller = labeller(
             f_emulsion = as_labeller(
               function(x) paste0("F[emulsion]: ", x, " * mu * L/hr"),
               label_parsed
             ),
             f_inject = as_labeller(
               function(x) paste0("F[inject]: ", x, " * mu * L/hr"),
               label_parsed
             )
           )) +
  scale_fill_viridis_c(option = "magma", name = "Droplet Lightness") +
  labs(
    title = "Droplet radii at 750V electrocoalescence colored by droplet lightness",
    x = "Droplet Radius (um)",
    y = "Count"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
  )
# ------ Histogram stuff end --------------------------------------------
```
Alright, the next graph I want to make is to see which experiments have the highest percentage of droplets between lightness values between 80 and 100.From the histograms, you can see that uninjected droplets are generally lower than 100 and spontaneous injections or large injection volumes are generally higher than 100.

# -----Start of lightness vs. experiment section -----------------------

These should satisfy 2 more of **Requirement 2C** 's explored variables. Here, I investigate the percentage of successfully injected droplets,which almost always end up between a lightness value of 80 and 100, as well as the number of valid or invalid droplets detected by my OpenCVprogram. I would expect that 'bad' experimental parameters would result in more invalid droplets (weird shapes, way too large, clumps) being detected. Both variables will be plotted on one plot.

```{r fig.width=16, fig.height=10}

# Make a new tibble for gray value (lightness) percentage. Should have both valid and invalid percentages
grayval_val_percentage <- droplet_data %>%
  # DON'T filter - we need both valid and invalid
  group_by(code) %>%
  summarise(
    total_droplets = n(),
    valid_droplets = sum(valid == "VALID", na.rm = TRUE),
    invalid_droplets = sum(valid != "VALID", na.rm = TRUE),
    # Of the VALID droplets, how many are in 80-100 range
    droplets_80_100 = sum(valid == "VALID" & grayval >= 80 & grayval <= 100, na.rm = TRUE),
    # Percentage of valid droplets with grayval 80-100 (out of ALL droplets)
    percentage_80_100 = (droplets_80_100 / total_droplets) * 100,
    # Percentage of invalid droplets (out of ALL droplets)
    percentage_invalid = (invalid_droplets / total_droplets) * 100,
    .groups = "drop"
  ) %>%
  mutate(
    exp_num = as.numeric(str_extract(code, "\\d+$"))
  ) %>%
  arrange(exp_num)

# Create the plot with legend
ggplot(grayval_val_percentage, aes(x = reorder(factor(exp_num), percentage_80_100))) +
  geom_point(aes(y = percentage_80_100, color = "Successful Injections"), size = 3) +
  geom_point(aes(y = percentage_invalid, color = "Invalid Droplets"), size = 3) +
  scale_color_manual(
    name = "Droplet Type",
    values = c("Successful Injections" = "black", "Invalid Droplets" = "red")
  ) +
  labs(
    title = "Droplet Quality by Experiment",
    x = "Experiment Code Number",
    y = "Percentage (%)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )
```
Okay, this graph shows quite a large difference in successful injections per experiment based on the conditions. And, since the previous histograms were labeled also by experiment number, we can see that the best experiment was 45, with Finject of 10 uL/hr and Femulsion at 15 uL/hr at 750V. However, it seems like the number of invalid droplets being detected is mostly the same across all experiments, with a noise level of around 10%. This does tell me that my OpenCV program performs consistently across the different conditions, though, I think.

# ------------ End of lightness vs experiment section -------------------------

Okay, now it's time for the covariance section. The first thing I'd like to examine is how the average droplet size is changing across one row of the faceted histogram graph for the 500V electrocoalescence setting (this is the row that apparently has the 'best') injection rate at Finject = 15 uL/r (experiment 65).I'm curious to see how the injection flowrate affects the average size and size standard deviation of the size for this group. That will be covariance measurement 1 to fulfill one of **2D** 's covariation tests. The next covariance test will be seeing how the average lightness of the droplets changes going across that same row, to fulfill the 2nd covariance test for **2D**. Finally, the 3rd covariance test will be seeing how the electrocoalescence voltage, for the f_emulsion of the best experiment across f_inject's, affects the lightness vs. size of the droplets. This will fulfill the third of **2D**'s covariation tests.

# Covariance test 1: Effect of Finject on droplet size when Femulsion is 20 uL/hr and voltage == 750V.

```{r fig.width=16, fig.height=10}

# Filter and calculate average radius for F_emulsion = 20 and voltage = 750V
radius_by_inject <- droplet_data %>%
  filter(valid == "VALID", f_emulsion == 20, voltage == 750) %>%
  group_by(f_inject) %>%
  # Here's where we get the mean and sdv
  summarise(
    avg_radius = mean(radius_um, na.rm = TRUE),
    sd_radius = sd(radius_um, na.rm = TRUE),
    .groups = "drop"
  )

# Create the line plot with errorbars and a black line.
ggplot(radius_by_inject, aes(x = f_inject, y = avg_radius)) +
  geom_errorbar(aes(ymin = avg_radius - sd_radius, ymax = avg_radius + sd_radius),
                width = 0.2, color = "red", linewidth = 0.8) +
  geom_point(size = 4, color = "black") +
  geom_line(color = "black", linewidth = 1) +
  labs(
    title = "Average Droplet Radius vs Injection Flow Rate",
    # Help define what conditions these results were obtained at.
    subtitle = expression(F[emulsion]~"= 20 uL/hr, Voltage = 750V"),
    x = expression(F[inject]~"(uL/hr)"),
    y = "Average Droplet Radius (um)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )
# Okay, that's pretty interesting. Seems like the droplet size changes quite
# a bit, on average, as Finject gets larger. Now let's examine how the lightness
# changes.

#----- End of covariance test 1------------------------------------------------
```

# ----- Start of covariance test 2-----------------------------------------

```{r fig.width=16, fig.height=10}
# Filter and calculate average grayval for F_emulsion = 20 and voltage = 750V
grayval_by_inject <- droplet_data %>%
  filter(valid == "VALID", f_emulsion == 20, voltage == 750) %>%
  group_by(f_inject) %>%
  # Everything up until here was the same; now we're doing grayval (a higher
  # grayval means the droplet is lighter). Recall that the injection solution
  # is light and the droplets start out dark.
  summarise(
    avg_grayval = mean(grayval, na.rm = TRUE),
    sd_grayval = sd(grayval, na.rm = TRUE),
    .groups = "drop"
  )

# Create the same type of plot as before.
ggplot(grayval_by_inject, aes(x = f_inject, y = avg_grayval)) +
  geom_errorbar(aes(ymin = avg_grayval - sd_grayval, ymax = avg_grayval + sd_grayval),
                width = 0.2, color = "red", linewidth = 0.8) +
  geom_point(size = 4, color = "black") +
  geom_line(color = "black", linewidth = 1) +
  labs(
    title = "Average Droplet GrayVal (Lightness) vs Injection Flow Rate",
    subtitle = expression(F[emulsion]~"= 20 uL/hr, Voltage = 750V"),
    x = expression(F[inject]~"(uL/hr)"),
    y = "Average Gray Value (A.U.)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )
# As expected, it does seem like droplets get lighter as the injection
# flowrate increases. Thus, I think it's reasonable to say that the average
# size increase is associated positively with the injection flowrate.
#------ End of covariance test 2----------------------------------------------
```

# Start of covariance test 3 -------------------------------------------------

```{r fig.width=16, fig.height=10}
# Make a new tibble for comparing how voltages affect successful injections.
voltage_comparison <- droplet_data %>%
  # I'm particularly interested in the group of experiments where f_emulsion
  # is 20 and f_inject is either 5, 10, or 15. See the histograms from the
  # exploratory analysis to see why. 
  filter(f_emulsion == 20, f_inject %in% c(5, 10, 15)) %>%
  group_by(f_emulsion, f_inject, voltage) %>%
  summarise(
    # Get the total droplets for each group.
    total_droplets = n(),
    # Figure out how many are between 80-100, the sweetspot for injections.
    droplets_80_100 = sum(valid == "VALID" & grayval >= 80 & grayval <= 100, na.rm = TRUE),
    # Percentage of successfully injected droplets (out of ALL droplets in group).
    percentage_success = (droplets_80_100 / total_droplets) * 100,
    .groups = "drop"
  )

# Create the bar plot. We'll facet by f_inject since f_emulsion is the same for all of them.
ggplot(voltage_comparison, aes(x = factor(voltage), y = percentage_success)) +
  geom_col(fill = "black", color = "black", linewidth = 0.5) +
  # We can label each bar with the number of successful injections so it's more
  # obvious what kind of sample size we're working with.
  geom_text(aes(label = droplets_80_100), 
            vjust = -0.5, 
            fontface = "bold", 
            size = 4) +
  facet_wrap(~ f_inject, 
             labeller = as_labeller(function(x) paste0("F[inject]: ", x, " * mu * L/hr"), 
                                    label_parsed)) +
  labs(
    title = "Successful Injection Rate by Voltage and Injection Flow Rate",
    subtitle = expression(F[emulsion]~"= 20 uL/hr"),
    x = "Voltage (V)",
    y = "Percentage of Successful Injections (%)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    strip.text = element_text(face = "bold"),
    axis.text = element_text(family = "sans", face = "bold"),
    panel.grid = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

# Interesting. Honestly, it's hard to tell if some of the differences are actually
# significant (but again, the sample sizes tend to be pretty large). I could run
# significance tests, but probably don't have the time to do that here. It seems
# like 500 volts is reproducibly the best condition, though.

#----- End of covariance test 3 -----------------------------------------------
```

# ----- Start of inter-variable tests; this section addresses **2D** part ii. 

So, looking at the plot of radius vs f_inject and grayval vs. f_inject, it more or less seems like there's a positive relationship for both. But, I'm curious to see, on the same faceted graph how the voltage affects these variables. I would expect lightness and size to be positively correlated (because if the droplet is lighter, it should have been injected with more light fluid.) The problem is that the current plots don't really decouple that from the voltage (because I only examined one voltage in that plot). I think I could make a very information rich plot by plotting, on the y axis, lightness, and on the  x-axis, radius in scatterplot format and color the points by their f_inject. I could then facet by voltage. I'm curious if voltage affects the strength of this relationship.

```{r fig.width=16, fig.height=10}

# Filter data for f_emulsion = 20 and valid droplets
scatter_data <- droplet_data %>%
  filter(valid == "VALID", f_emulsion == 20)

# Create the scatterplot. Color by f_inject.
ggplot(scatter_data, aes(x = radius_um, y = grayval, color = factor(f_inject))) +
  geom_point(alpha = 0.6, size = 2) +
  # Make a trendline.
  geom_smooth(method = "lm", se = FALSE, linewidth = 3) +
  # Facet by voltage.
  facet_wrap(~ voltage, 
             labeller = labeller(voltage = function(x) paste0(x, " V"))) +
  scale_color_viridis_d(option = "magma", 
                        name = expression(F[inject]~"(uL/hr)")) +
  labs(
    title = "Droplet Gray Value vs Radius by Injection Flow Rate",
    subtitle = expression(F[emulsion]~"= 20 uL/hr"),
    x = "Droplet Radius (um)",
    y = "Gray Value (A.U.)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "sans", face = "bold"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    strip.text = element_text(face = "bold"),
    axis.text = element_text(family = "sans", face = "bold"),
    legend.position = "right"
  )
``` 

# End of inter-variables tests.

Okay, interesting. For some f_inject's, (all up until 25), the lowest voltage has a steep slope, the middle has a low slope, and the highest has a steep slope. But for the 25 uL/Hr f_inject, the slope gets steeper. I think this is happening because we see a more exaggerated 'light and large' droplet population at that parameter (which is suboptimal if you look at the histograms from before. On the other hand, the more optimal conditions (such as the Finject of 10, purple) are more tightly clustered in one group at the center, and as such, the correlation line is shallower.It is in fact the shallowest line. Though in the future, K means clustering may be a better way to find the tightest settings.

# End of midterm project!
